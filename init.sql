CREATE SCHEMA IF NOT EXISTS ess;
CREATE TABLE ess.exception_log (
    log_id UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- Unique identifier for the log record
    function_name VARCHAR(255) NOT NULL, -- Name of the function where the exception occurred
    error_message TEXT NOT NULL, -- Error message (SQLERRM)
    executed_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- Timestamp of when the exception occurred
    executed_by VARCHAR(255) -- User who executed the function (optional)
); 

CREATE TABLE ess.roles (
    role_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_name VARCHAR(100) NOT NULL,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP
);

INSERT INTO ess.roles (role_name, createdby, created_timestamp)
VALUES ('employee', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.roles (role_name, createdby, created_timestamp)
VALUES ('hr_department', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.roles (role_name, createdby, created_timestamp)
VALUES ('company_management', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.roles (role_name, createdby, created_timestamp)
VALUES ('admin', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.roles (role_name, createdby, created_timestamp)
VALUES ('super_admin', 'system', CURRENT_TIMESTAMP);

CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.department (
    department_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    department_name VARCHAR(255) NOT NULL,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP
);

INSERT INTO ess.department (department_name, createdby, created_timestamp)
VALUES ('human_resources', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.department (department_name, createdby, created_timestamp)
VALUES ('engineering', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.department (department_name, createdby, created_timestamp)
VALUES ('finance', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.department (department_name, createdby, created_timestamp)
VALUES ('marketing', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.department (department_name, createdby, created_timestamp)
VALUES ('operations', 'system', CURRENT_TIMESTAMP);


CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.users (
    user_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    role_id INTEGER NOT NULL,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP,
    CONSTRAINT fk_role FOREIGN KEY (role_id) REFERENCES ess.roles(role_id)
);

INSERT INTO ess.users (username, email, password, role_id, createdby, created_timestamp)
VALUES ('john_doe', 'john.doe@example.com', 'hashed_password1', 1, 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.users (username, email, password, role_id, createdby, created_timestamp)
VALUES ('jane_smith', 'jane.smith@example.com', 'hashed_password2', 2, 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.users (username, email, password, role_id, createdby, created_timestamp)
VALUES ('michael_brown', 'michael.brown@example.com', 'hashed_password3', 3, 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.users (username, email, password, role_id, createdby, created_timestamp)
VALUES ('alice_jones', 'alice.jones@example.com', 'hashed_password4', 4, 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.users (username, email, password, role_id, createdby, created_timestamp)
VALUES ('bob_davis', 'bob.davis@example.com', 'hashed_password5', 5, 'system', CURRENT_TIMESTAMP);




CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.skills (
    skill_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    skill_name VARCHAR(100) NOT NULL,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP
);

INSERT INTO ess.skills (skill_name, createdby, created_timestamp)
VALUES ('python', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.skills (skill_name, createdby, created_timestamp)
VALUES ('sql', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.skills (skill_name, createdby, created_timestamp)
VALUES ('react', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.skills (skill_name, createdby, created_timestamp)
VALUES ('flask', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.skills (skill_name, createdby, created_timestamp)
VALUES ('javascript', 'system', CURRENT_TIMESTAMP);


CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.employees (
    employee_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_name VARCHAR(255) NOT NULL,
    doj DATE NOT NULL,
    total_experience NUMERIC(4,2) NOT NULL,
    designation VARCHAR(255) NOT NULL,
    reporting_manager VARCHAR(255),
    work_location VARCHAR(255),
    personal_email VARCHAR(255),
    company_email VARCHAR(255),
    gender VARCHAR(50),
    date_of_birth DATE,
    present_address TEXT,
    permanent_address TEXT,
    contact_number VARCHAR(50),
    alternate_contact_number VARCHAR(255),
    fathers_name VARCHAR(255),
    marital_status VARCHAR(50),
    pan_number VARCHAR(50),
    aadhar_number VARCHAR(50),
    blood_group VARCHAR(10),
    passport_number VARCHAR(50),
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP
);

INSERT INTO ess.employees (
    employee_name,
    doj,
    total_experience,
    designation,
    reporting_manager,
    work_location,
    personal_email,
    company_email,
    gender,
    date_of_birth,
    present_address,
    permanent_address,
    contact_number,
    alternate_contact_number,
    fathers_name,
    marital_status,
    pan_number,
    aadhar_number,
    blood_group,
    passport_number,
    createdby,
    created_timestamp
) VALUES (
    'john doe',
    '2020-01-15',
    5.50,
    'software engineer',
    'jane smith',
    'new york',
    'john.doe@gmail.com',
    'john.doe@company.com',
    'male',
    '1990-05-20',
    '123 main st, new york, ny',
    '456 elm st, boston, ma',
    '555-1234',
    'mary doe - wife: 555-5678',
    'robert doe',
    'married',
    'abcde1234f',
    '123412341234',
    'o+',
    'x1234567',
    'system',
    CURRENT_TIMESTAMP
);

INSERT INTO ess.employees (
    employee_name,
    doj,
    total_experience,
    designation,
    reporting_manager,
    work_location,
    personal_email,
    company_email,
    gender,
    date_of_birth,
    present_address,
    permanent_address,
    contact_number,
    alternate_contact_number,
    fathers_name,
    marital_status,
    pan_number,
    aadhar_number,
    blood_group,
    passport_number,
    createdby,
    created_timestamp
) VALUES (
    'alice johnson',
    '2019-03-10',
    7.00,
    'project manager',
    NULL,
    'san francisco',
    'alice.johnson@gmail.com',
    'alice.johnson@company.com',
    'female',
    '1985-07-15',
    '789 pine st, san francisco, ca',
    '101 maple ave, oakland, ca',
    '555-2345',
    'bob johnson - husband: 555-6789',
    'william johnson',
    'married',
    'fghij5678k',
    '234523452345',
    'a+',
    'y2345678',
    'system',
    CURRENT_TIMESTAMP
);

INSERT INTO ess.employees (
    employee_name,
    doj,
    total_experience,
    designation,
    reporting_manager,
    work_location,
    personal_email,
    company_email,
    gender,
    date_of_birth,
    present_address,
    permanent_address,
    contact_number,
    alternate_contact_number,
    fathers_name,
    marital_status,
    pan_number,
    aadhar_number,
    blood_group,
    passport_number,
    createdby,
    created_timestamp
) VALUES (
    'michael smith',
    '2021-06-01',
    3.75,
    'data analyst',
    'alice johnson',
    'chicago',
    'michael.smith@gmail.com',
    'michael.smith@company.com',
    'male',
    '1992-11-30',
    '321 oak st, chicago, il',
    '654 spruce st, chicago, il',
    '555-3456',
    'laura smith - sister: 555-7890',
    'george smith',
    'single',
    'klmno9101p',
    '345634563456',
    'b-',
    'z3456789',
    'system',
    CURRENT_TIMESTAMP
);

INSERT INTO ess.employees (
    employee_name,
    doj,
    total_experience,
    designation,
    reporting_manager,
    work_location,
    personal_email,
    company_email,
    gender,
    date_of_birth,
    present_address,
    permanent_address,
    contact_number,
    alternate_contact_number,
    fathers_name,
    marital_status,
    pan_number,
    aadhar_number,
    blood_group,
    passport_number,
    createdby,
    created_timestamp
) VALUES (
    'emily davis',
    '2018-09-25',
    10.00,
    'senior manager',
    'n/a',
    'los angeles',
    'emily.davis@gmail.com',
    'emily.davis@company.com',
    'female',
    '1980-04-12',
    '987 cedar st, los angeles, ca',
    '654 birch rd, los angeles, ca',
    '555-4567',
    'john davis - husband: 555-8901',
    'richard davis',
    'married',
    'pqrst2345u',
    '456745674567',
    'ab+',
    'w4567890',
    'system',
    CURRENT_TIMESTAMP
);

INSERT INTO ess.employees (
    employee_name,
    doj,
    total_experience,
    designation,
    reporting_manager,
    work_location,
    personal_email,
    company_email,
    gender,
    date_of_birth,
    present_address,
    permanent_address,
    contact_number,
    alternate_contact_number,
    fathers_name,
    marital_status,
    pan_number,
    aadhar_number,
    blood_group,
    passport_number,
    createdby,
    created_timestamp
) VALUES (
    'david wilson',
    '2022-01-05',
    1.25,
    'junior developer',
    'emily davis',
    'austin',
    'david.wilson@gmail.com',
    'david.wilson@company.com',
    'male',
    '1998-02-18',
    '159 walnut st, austin, tx',
    '753 cherry st, austin, tx',
    '555-5678',
    'sarah wilson - sister: 555-9012',
    'edward wilson',
    'single',
    'uvwxy6789z',
    '567856785678',
    'o-',
    'v5678901',
    'system',
    CURRENT_TIMESTAMP
);




CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.employee_past_experience (
    experience_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id INTEGER NOT NULL,
    company_name VARCHAR(255) NOT NULL,
    project_name VARCHAR(255) NOT NULL,
    client_name VARCHAR(255),
    project_start_date DATE NOT NULL,
    project_end_date DATE,
    project_activities TEXT,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP,
    CONSTRAINT fk_employee FOREIGN KEY (employee_id) REFERENCES ess.employees(employee_id)
);

INSERT INTO ess.employee_past_experience (employee_id, company_name, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (1, 'abc corp', 'project alpha', 'client a', '2018-01-01', '2018-06-30', 'developed backend apis', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_past_experience (employee_id, company_name, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (1, 'xyz ltd', 'project beta', 'client b', '2019-02-15', '2019-12-15', 'worked on database design', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_past_experience (employee_id, company_name, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (2, 'tech solutions', 'project gamma', 'client c', '2017-05-10', '2018-05-10', 'led team and managed projects', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_past_experience (employee_id, company_name, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (3, 'datacorp', 'project delta', 'client d', '2020-03-01', '2020-09-01', 'data analysis and reporting', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_past_experience (employee_id, company_name, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (4, 'innovatech', 'project epsilon', 'client e', '2015-11-01', '2016-05-01', 'managed cross-functional teams', 'system', CURRENT_TIMESTAMP);





CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.employee_otsi_experience (
    otsi_experience_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id INTEGER NOT NULL,
    project_name VARCHAR(255) NOT NULL,
    client_name VARCHAR(255),
    project_start_date DATE NOT NULL,
    project_end_date DATE,
    project_activities TEXT,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP,
    CONSTRAINT fk_employee FOREIGN KEY (employee_id) REFERENCES ess.employees(employee_id)
);

INSERT INTO ess.employee_otsi_experience (employee_id, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (1, 'otsi project alpha', 'client x', '2019-01-10', '2019-06-30', 'implemented microservices architecture', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_otsi_experience (employee_id, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (2, 'otsi project beta', 'client y', '2018-03-15', '2018-09-15', 'developed RESTful APIs', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_otsi_experience (employee_id, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (3, 'otsi project gamma', 'client z', '2020-07-01', '2020-12-31', 'migrated legacy systems', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_otsi_experience (employee_id, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (4, 'otsi project delta', 'client w', '2017-05-20', '2017-11-20', 'optimized database queries', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_otsi_experience (employee_id, project_name, client_name, project_start_date, project_end_date, project_activities, createdby, created_timestamp)
VALUES (5, 'otsi project epsilon', 'client v', '2021-02-01', '2021-08-01', 'integrated third-party services', 'system', CURRENT_TIMESTAMP);




CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.employee_education (
    education_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id INTEGER NOT NULL,
    year_passed_out INTEGER NOT NULL,
    education VARCHAR(255) NOT NULL,
    college_university VARCHAR(255) NOT NULL,
    major_subjects TEXT[] NOT NULL,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP,
    CONSTRAINT fk_employee FOREIGN KEY (employee_id) REFERENCES ess.employees(employee_id)
);

INSERT INTO ess.employee_education (employee_id, year_passed_out, education, college_university, major_subjects, createdby, created_timestamp)
VALUES (1, 2012, 'B.Tech', 'Massachusetts Institute of Technology', ARRAY['Computer Science', 'Engineering'], 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_education (employee_id, year_passed_out, education, college_university, major_subjects, createdby, created_timestamp)
VALUES (2, 2010, 'B.Sc', 'Stanford University', ARRAY['Biology', 'Chemistry'], 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_education (employee_id, year_passed_out, education, college_university, major_subjects, createdby, created_timestamp)
VALUES (3, 2015, 'M.Sc', 'University of California, Berkeley', ARRAY['Mathematics', 'Statistics'], 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_education (employee_id, year_passed_out, education, college_university, major_subjects, createdby, created_timestamp)
VALUES (4, 2008, 'MBA', 'Harvard Business School', ARRAY['Management', 'Finance'], 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_education (employee_id, year_passed_out, education, college_university, major_subjects, createdby, created_timestamp)
VALUES (5, 2016, 'B.Com', 'University of Chicago', ARRAY['Accounting', 'Economics'], 'system', CURRENT_TIMESTAMP);



CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.employee_skills (
    employee_skill_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id INTEGER NOT NULL,
    skill_id INTEGER NOT NULL,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP,
    CONSTRAINT fk_employee FOREIGN KEY (employee_id) REFERENCES ess.employees(employee_id),
    CONSTRAINT fk_skill FOREIGN KEY (skill_id) REFERENCES ess.skills(skill_id)
);

INSERT INTO ess.employee_skills (employee_id, skill_id, createdby, created_timestamp)
VALUES (1, 1, 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_skills (employee_id, skill_id, createdby, created_timestamp)
VALUES (1, 2, 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_skills (employee_id, skill_id, createdby, created_timestamp)
VALUES (2, 3, 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_skills (employee_id, skill_id, createdby, created_timestamp)
VALUES (3, 4, 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_skills (employee_id, skill_id, createdby, created_timestamp)
VALUES (4, 5, 'system', CURRENT_TIMESTAMP);



CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.employee_certifications (
    employee_certification_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id INTEGER NOT NULL,
    certification_name VARCHAR(255) NOT NULL,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP,
    CONSTRAINT fk_employee FOREIGN KEY (employee_id) REFERENCES ess.employees(employee_id)
);

INSERT INTO ess.employee_certifications (employee_id, certification_name, createdby, created_timestamp)
VALUES (1, 'Certified Java Developer', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_certifications (employee_id, certification_name, createdby, created_timestamp)
VALUES (2, 'AWS Certified Solutions Architect', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_certifications (employee_id, certification_name, createdby, created_timestamp)
VALUES (3, 'PMP Certification', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_certifications (employee_id, certification_name, createdby, created_timestamp)
VALUES (4, 'Certified Data Analyst', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.employee_certifications (employee_id, certification_name, createdby, created_timestamp)
VALUES (5, 'Scrum Master Certification', 'system', CURRENT_TIMESTAMP);



CREATE SCHEMA IF NOT EXISTS ess;

CREATE TABLE ess.otp (
    otp_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id INTEGER NOT NULL,
    otp_code VARCHAR(10) NOT NULL,
    otp_status VARCHAR(50) NOT NULL,
    valid_until TIMESTAMP NOT NULL,
    createdby VARCHAR(100) NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    modifiedby VARCHAR(100),
    modified_timestamp TIMESTAMP,
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES ess.users(user_id)
);

INSERT INTO ess.otp (user_id, otp_code, otp_status, valid_until, createdby, created_timestamp)
VALUES (1, '123456', 'pending', '2025-02-01 12:00:00', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.otp (user_id, otp_code, otp_status, valid_until, createdby, created_timestamp)
VALUES (2, '654321', 'used', '2025-02-01 12:05:00', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.otp (user_id, otp_code, otp_status, valid_until, createdby, created_timestamp)
VALUES (3, '111222', 'pending', '2025-02-01 12:10:00', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.otp (user_id, otp_code, otp_status, valid_until, createdby, created_timestamp)
VALUES (4, '333444', 'expired', '2025-02-01 11:50:00', 'system', CURRENT_TIMESTAMP);

INSERT INTO ess.otp (user_id, otp_code, otp_status, valid_until, createdby, created_timestamp)
VALUES (5, '555666', 'pending', '2025-02-01 12:15:00', 'system', CURRENT_TIMESTAMP);








CREATE OR REPLACE FUNCTION ess.fn_create_role(
    _role_name TEXT,
    _user_id TEXT
) 
RETURNS JSON AS $$
/*
    Function: fn_create_role
    Purpose:  Inserts a new role into the ess.roles table and returns the inserted record in JSON format.
    Parameters:
        _role_name  - Role name to be inserted (must match column name, prefixed with _)
        _user_id    - User id executing the function (used for createdby and exception logging)
    Returns:
        JSON array with the inserted role details, e.g., [{"role_id": 1, "role_name": "employee", "message": "Role created successfully"}]
    Test Call:
        SELECT ess.fn_create_role('employee', '1');
*/
DECLARE
    l_role_id INTEGER;  -- Local variable to store the new role id
    l_result JSON;      -- Local variable to store the final JSON result
BEGIN
    -- Insert new role and capture the generated role_id
    INSERT INTO ess.roles (role_name, createdby, created_timestamp)
    VALUES (_role_name, _user_id, CURRENT_TIMESTAMP)
    RETURNING role_id INTO l_role_id;
    
    -- Build the JSON result array
    l_result := json_build_array(
                    json_build_object(
                        'role_id', l_role_id,
                        'role_name', _role_name,
                        'message', 'Role created successfully'
                    )
                );
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        -- Log the exception details into the exception_log table
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_role', SQLERRM, _user_id);
        
        -- Return the exception details in JSON format
        RETURN json_build_array(
                    json_build_object(
                        'error', SQLERRM
                    )
                );
END;
$$ LANGUAGE plpgsql;






CREATE OR REPLACE FUNCTION ess.fn_read_role(
    _user_id TEXT,
    _role_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_role
    Purpose:  Reads role details from the ess.roles table.
              If _role_ids is provided, returns the roles matching those IDs;
              otherwise returns all roles.
    Parameters:
        _user_id  - User ID executing the function (used for security and exception logging).
        _role_ids - Array of role IDs to filter by (optional).
    Returns:
        A JSON array containing role objects, e.g.,
        [{"role_id": 1, "role_name": "employee", "createdby": "system", ...}]
    Test Calls:
        SELECT ess.fn_read_role('1', ARRAY[1,2]);
        SELECT ess.fn_read_role('1');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _role_ids IS NOT NULL THEN
        SELECT json_agg(role_rec) INTO l_result
        FROM (
            SELECT role_id, role_name, createdby, created_timestamp, modifiedby, modified_timestamp
            FROM ess.roles
            WHERE role_id = ANY(_role_ids)
        ) AS role_rec;
    ELSE
        SELECT json_agg(role_rec) INTO l_result
        FROM (
            SELECT role_id, role_name, createdby, created_timestamp, modifiedby, modified_timestamp
            FROM ess.roles
        ) AS role_rec;
    END IF;

    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;

    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_role', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;






CREATE OR REPLACE FUNCTION ess.fn_update_role(
    _role_id INTEGER,
    _role_name TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_update_role
    Purpose:  Updates the role name in the ess.roles table for a given role_id.
    Parameters:
        _role_id   - Role ID to update (must match the column name, prefixed with _)
        _role_name - New role name (must match the column name, prefixed with _)
        _user_id   - User ID executing the function (used for auditing and exception logging)
    Returns:
        A JSON array containing the updated role details, e.g.,
        [{"role_id": 1, "role_name": "new_role_name", "message": "Role updated successfully"}]
    Test Call:
        SELECT ess.fn_update_role(1, 'new_role_name', '1');
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    -- Update the role with the new role name and set modification details
    UPDATE ess.roles
    SET role_name = _role_name,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE role_id = _role_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    -- Build result based on whether the update was successful
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'role_id', _role_id,
                            'message', 'No role found with the provided role_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'role_id', _role_id,
                            'role_name', _role_name,
                            'message', 'Role updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        -- Log the exception into the exception_log table
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_role', SQLERRM, _user_id);
        -- Return the exception details in JSON format
        RETURN json_build_array(
                    json_build_object(
                        'error', SQLERRM
                    )
                );
END;
$$ LANGUAGE plpgsql;








CREATE OR REPLACE FUNCTION ess.fn_delete_role(
    _role_id INTEGER,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_delete_role
    Purpose:  Deletes a role from the ess.roles table based on the provided role_id.
    Parameters:
        _role_id  - Role ID to be deleted (must match the column name, prefixed with _)
        _user_id  - User ID executing the function (used for auditing and exception logging)
    Returns:
        A JSON array containing a message about the deletion result, e.g.,
        [{"role_id": 1, "message": "Role deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_role(1, '1');
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.roles WHERE role_id = _role_id;
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'role_id', _role_id,
                            'message', 'No role found with the provided role_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'role_id', _role_id,
                            'message', 'Role deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_role', SQLERRM, _user_id);
        RETURN json_build_array(
                    json_build_object(
                        'error', SQLERRM
                    )
                );
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION ess.fn_create_department(
    _department_name TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_create_department
    Purpose:  Inserts a new department into the ess.department table and returns the inserted record in JSON format.
    Parameters:
        _department_name - Department name to be inserted.
        _user_id         - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the inserted department details, e.g.:
        [{"department_id": 1, "department_name": "engineering", "message": "Department created successfully"}]
    Test Call:
        SELECT ess.fn_create_department('engineering', '1');
*/
DECLARE
    l_department_id INTEGER;  -- Local variable to store the new department ID
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.department (department_name, createdby, created_timestamp)
    VALUES (_department_name, _user_id, CURRENT_TIMESTAMP)
    RETURNING department_id INTO l_department_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'department_id', l_department_id,
                        'department_name', _department_name,
                        'message', 'Department created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_department', SQLERRM, _user_id);
        RETURN json_build_array(
                    json_build_object('error', SQLERRM)
                );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ess.fn_read_department(
    _user_id TEXT,
    _department_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_department
    Purpose:  Reads department details from the ess.department table.
              If _department_ids is provided, returns the departments matching those IDs;
              otherwise returns all departments.
    Parameters:
        _user_id         - User ID executing the function (used for auditing and exception logging).
        _department_ids  - Array of department IDs to filter by (optional).
    Returns:
        A JSON array containing department objects, e.g.:
        [{"department_id": 1, "department_name": "engineering", "createdby": "system", ...}]
    Test Calls:
        SELECT ess.fn_read_department('1', ARRAY[1,2]);
        SELECT ess.fn_read_department('1');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _department_ids IS NOT NULL THEN
        SELECT json_agg(dept_rec) INTO l_result
        FROM (
            SELECT department_id, department_name, createdby, created_timestamp, modifiedby, modified_timestamp
            FROM ess.department
            WHERE department_id = ANY(_department_ids)
        ) AS dept_rec;
    ELSE
        SELECT json_agg(dept_rec) INTO l_result
        FROM (
            SELECT department_id, department_name, createdby, created_timestamp, modifiedby, modified_timestamp
            FROM ess.department
        ) AS dept_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_department', SQLERRM, _user_id);
        RETURN json_build_array(
                    json_build_object('error', SQLERRM)
                );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ess.fn_update_department(
    _department_id INTEGER,
    _department_name TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_update_department
    Purpose:  Updates the department name in the ess.department table for a given department_id.
    Parameters:
        _department_id   - Department ID to update.
        _department_name - New department name.
        _user_id         - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the updated department details, e.g.:
        [{"department_id": 1, "department_name": "new_engineering", "message": "Department updated successfully"}]
    Test Call:
        SELECT ess.fn_update_department(1, 'new_engineering', '1');
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.department
    SET department_name = _department_name,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE department_id = _department_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'department_id', _department_id,
                            'message', 'No department found with the provided department_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'department_id', _department_id,
                            'department_name', _department_name,
                            'message', 'Department updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_department', SQLERRM, _user_id);
        RETURN json_build_array(
                    json_build_object('error', SQLERRM)
                );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ess.fn_delete_department(
    _department_id INTEGER,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_delete_department
    Purpose:  Deletes a department from the ess.department table based on the provided department_id.
    Parameters:
        _department_id - Department ID to be deleted.
        _user_id       - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"department_id": 1, "message": "Department deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_department(1, '1');
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.department
    WHERE department_id = _department_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'department_id', _department_id,
                            'message', 'No department found with the provided department_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'department_id', _department_id,
                            'message', 'Department deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_department', SQLERRM, _user_id);
        RETURN json_build_array(
                    json_build_object('error', SQLERRM)
                );
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION ess.fn_create_user(
    _username TEXT,
    _email TEXT,
    _password TEXT,
    _role_id INTEGER,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_create_user
    Purpose:  Inserts a new user into the ess.users table and returns the inserted record in JSON format.
    Parameters:
        _username - Username for the new user.
        _email    - Email for the new user.
        _password - Password for the new user.
        _role_id  - Role ID for the new user.
        _user_id  - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the inserted user details, e.g.:
        [{"user_id": 1, "username": "john_doe", "email": "john.doe@example.com", "role_id": 1, "message": "User created successfully"}]
    Test Call:
        SELECT ess.fn_create_user('john_doe', 'john.doe@example.com', 'hashed_password', 1, 'admin');
*/
DECLARE
    l_user_id INTEGER;  -- Local variable to store the new user ID
    l_result JSON;      -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.users (username, email, password, role_id, createdby, created_timestamp)
    VALUES (_username, _email, _password, _role_id, _user_id, CURRENT_TIMESTAMP)
    RETURNING user_id INTO l_user_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'user_id', l_user_id,
                        'username', _username,
                        'email', _email,
                        'role_id', _role_id,
                        'message', 'User created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_user', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_read_user(
    _user_id TEXT,
    _target_user_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_user
    Purpose:  Reads user details from the ess.users table.
              If _target_user_ids is provided, returns the users matching those IDs;
              otherwise returns all users.
    Parameters:
        _user_id         - User ID executing the function (used for auditing and exception logging).
        _target_user_ids - Array of user IDs to filter by (optional).
    Returns:
        A JSON array containing user objects, e.g.:
        [{"user_id": 1, "username": "john_doe", "email": "john.doe@example.com", "role_id": 1, ...}]
    Test Calls:
        SELECT ess.fn_read_user('admin', ARRAY[1,2]);
        SELECT ess.fn_read_user('admin');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _target_user_ids IS NOT NULL THEN
        SELECT json_agg(user_rec) INTO l_result
        FROM (
            SELECT user_id, username, email, role_id, createdby, created_timestamp, modifiedby, modified_timestamp
            FROM ess.users
            WHERE user_id = ANY(_target_user_ids)
        ) AS user_rec;
    ELSE
        SELECT json_agg(user_rec) INTO l_result
        FROM (
            SELECT user_id, username, email, role_id, createdby, created_timestamp, modifiedby, modified_timestamp
            FROM ess.users
        ) AS user_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_user', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_update_user(
    _user_id TEXT,
    _target_user_id INTEGER,
    _username TEXT,
    _email TEXT,
    _password TEXT,
    _role_id INTEGER
)
RETURNS JSON AS $$
/*
    Function: fn_update_user
    Purpose:  Updates user details in the ess.users table for a given user record.
    Parameters:
        _user_id        - User ID executing the function (used for auditing and exception logging).
        _target_user_id - User ID of the record to update.
        _username       - New username.
        _email          - New email.
        _password       - New password.
        _role_id        - New role ID.
    Returns:
        A JSON array containing the updated user details, e.g.:
        [{"user_id": 1, "username": "new_username", "email": "new.email@example.com", "role_id": 2, "message": "User updated successfully"}]
    Test Call:
        SELECT ess.fn_update_user('admin', 1, 'new_username', 'new.email@example.com', 'new_hashed_password', 2);
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.users
    SET username = _username,
        email = _email,
        password = _password,
        role_id = _role_id,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE user_id = _target_user_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'user_id', _target_user_id,
                            'message', 'No user found with the provided user_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'user_id', _target_user_id,
                            'username', _username,
                            'email', _email,
                            'role_id', _role_id,
                            'message', 'User updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_user', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_delete_user(
    _user_id TEXT,
    _target_user_id INTEGER
)
RETURNS JSON AS $$
/*
    Function: fn_delete_user
    Purpose:  Deletes a user from the ess.users table based on the provided user_id.
    Parameters:
        _user_id        - User ID executing the function (used for auditing and exception logging).
        _target_user_id - User ID of the record to be deleted.
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"user_id": 1, "message": "User deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_user('admin', 1);
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.users
    WHERE user_id = _target_user_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'user_id', _target_user_id,
                            'message', 'No user found with the provided user_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'user_id', _target_user_id,
                            'message', 'User deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_user', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION ess.fn_create_skill(
    _skill_name TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_create_skill
    Purpose:  Inserts a new skill into the ess.skills table and returns the inserted record in JSON format.
    Parameters:
        _skill_name - Name of the skill to be inserted.
        _user_id    - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the inserted skill details, e.g.:
        [{"skill_id": 1, "skill_name": "python", "message": "Skill created successfully"}]
    Test Call:
        SELECT ess.fn_create_skill('python', 'admin');
*/
DECLARE
    l_skill_id INTEGER;  -- Local variable to store the new skill ID
    l_result JSON;       -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.skills (skill_name, createdby, created_timestamp)
    VALUES (_skill_name, _user_id, CURRENT_TIMESTAMP)
    RETURNING skill_id INTO l_skill_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'skill_id', l_skill_id,
                        'skill_name', _skill_name,
                        'message', 'Skill created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_skill', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_read_skill(
    _user_id TEXT,
    _skill_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_skill
    Purpose:  Reads skill details from the ess.skills table.
              If _skill_ids is provided, returns the skills matching those IDs; otherwise returns all skills.
    Parameters:
        _user_id   - User ID executing the function (used for auditing and exception logging).
        _skill_ids - Array of skill IDs to filter by (optional).
    Returns:
        A JSON array containing skill objects, e.g.:
        [{"skill_id": 1, "skill_name": "python", "createdby": "admin", ...}]
    Test Calls:
        SELECT ess.fn_read_skill('admin', ARRAY[1,2]);
        SELECT ess.fn_read_skill('admin');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _skill_ids IS NOT NULL THEN
        SELECT json_agg(skill_rec) INTO l_result
        FROM (
            SELECT skill_id, skill_name, createdby, created_timestamp, modifiedby, modified_timestamp
            FROM ess.skills
            WHERE skill_id = ANY(_skill_ids)
        ) AS skill_rec;
    ELSE
        SELECT json_agg(skill_rec) INTO l_result
        FROM (
            SELECT skill_id, skill_name, createdby, created_timestamp, modifiedby, modified_timestamp
            FROM ess.skills
        ) AS skill_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_skill', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_update_skill(
    _skill_id INTEGER,
    _skill_name TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_update_skill
    Purpose:  Updates the skill name in the ess.skills table for a given skill_id.
    Parameters:
        _skill_id   - Skill ID to update.
        _skill_name - New skill name.
        _user_id    - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the updated skill details, e.g.:
        [{"skill_id": 1, "skill_name": "new_python", "message": "Skill updated successfully"}]
    Test Call:
        SELECT ess.fn_update_skill(1, 'new_python', 'admin');
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.skills
    SET skill_name = _skill_name,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE skill_id = _skill_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'skill_id', _skill_id,
                            'message', 'No skill found with the provided skill_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'skill_id', _skill_id,
                            'skill_name', _skill_name,
                            'message', 'Skill updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_skill', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_delete_skill(
    _user_id TEXT,
    _skill_id INTEGER
)
RETURNS JSON AS $$
/*
    Function: fn_delete_skill
    Purpose:  Deletes a skill from the ess.skills table based on the provided skill_id.
    Parameters:
        _user_id  - User ID executing the function (used for auditing and exception logging).
        _skill_id - Skill ID to be deleted.
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"skill_id": 1, "message": "Skill deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_skill('admin', 1);
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.skills
    WHERE skill_id = _skill_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'skill_id', _skill_id,
                            'message', 'No skill found with the provided skill_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'skill_id', _skill_id,
                            'message', 'Skill deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_skill', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION ess.fn_create_employee(
    _employee_name TEXT,
    _doj DATE,
    _total_experience NUMERIC(4,2),
    _designation TEXT,
    _reporting_manager TEXT,
    _work_location TEXT,
    _personal_email TEXT,
    _company_email TEXT,
    _gender TEXT,
    _date_of_birth DATE,
    _present_address TEXT,
    _permanent_address TEXT,
    _contact_number TEXT,
    _alternate_contact_number TEXT,
    _fathers_name TEXT,
    _marital_status TEXT,
    _pan_number TEXT,
    _aadhar_number TEXT,
    _blood_group TEXT,
    _passport_number TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_create_employee
    Purpose:  Inserts a new employee into the ess.employees table and returns the inserted record in JSON format.
    Parameters:
        _employee_name            - Employee's name.
        _doj                      - Date of joining.
        _total_experience         - Total years of experience.
        _designation              - Employee's designation.
        _reporting_manager        - Reporting manager's name.
        _work_location            - Work location.
        _personal_email           - Personal email address.
        _company_email            - Company email address.
        _gender                   - Gender.
        _date_of_birth            - Date of birth.
        _present_address          - Present address.
        _permanent_address        - Permanent address.
        _contact_number           - Contact number.
        _alternate_contact_number - Alternate contact number.
        _fathers_name             - Father's name.
        _marital_status           - Marital status.
        _pan_number               - PAN number.
        _aadhar_number            - Aadhar number.
        _blood_group              - Blood group.
        _passport_number          - Passport number.
        _user_id                  - User ID executing the function.
    Returns:
        A JSON array containing the inserted employee details, e.g.:
        [{"employee_id": 1, "employee_name": "John Doe", "message": "Employee created successfully"}]
    Test Call:
        SELECT ess.fn_create_employee(
            'John Doe',
            '2020-01-15',
            5.50,
            'Software Engineer',
            'Jane Smith',
            'New York',
            'john.doe@gmail.com',
            'john.doe@company.com',
            'male',
            '1990-05-20',
            '123 Main St, New York, NY',
            '456 Elm St, Boston, MA',
            '555-1234',
            'Mary Doe - Wife: 555-5678',
            'Robert Doe',
            'married',
            'ABCDE1234F',
            '123412341234',
            'O+',
            'X1234567',
            'admin'
        );
*/
DECLARE
    l_employee_id INTEGER;  -- Local variable to store the new employee ID
    l_result JSON;          -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.employees (
        employee_name,
        doj,
        total_experience,
        designation,
        reporting_manager,
        work_location,
        personal_email,
        company_email,
        gender,
        date_of_birth,
        present_address,
        permanent_address,
        contact_number,
        alternate_contact_number,
        fathers_name,
        marital_status,
        pan_number,
        aadhar_number,
        blood_group,
        passport_number,
        createdby,
        created_timestamp
    )
    VALUES (
        _employee_name,
        _doj,
        _total_experience,
        _designation,
        _reporting_manager,
        _work_location,
        _personal_email,
        _company_email,
        _gender,
        _date_of_birth,
        _present_address,
        _permanent_address,
        _contact_number,
        _alternate_contact_number,
        _fathers_name,
        _marital_status,
        _pan_number,
        _aadhar_number,
        _blood_group,
        _passport_number,
        _user_id,
        CURRENT_TIMESTAMP
    )
    RETURNING employee_id INTO l_employee_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'employee_id', l_employee_id,
                        'employee_name', _employee_name,
                        'message', 'Employee created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_employee', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_read_employee(
    _user_id TEXT,
    _employee_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_employee
    Purpose:  Reads employee details from the ess.employees table.
              If _employee_ids is provided, returns the employees matching those IDs;
              otherwise returns all employees.
    Parameters:
        _user_id      - User ID executing the function.
        _employee_ids - Array of employee IDs to filter by (optional).
    Returns:
        A JSON array containing employee objects, e.g.:
        [{"employee_id": 1, "employee_name": "John Doe", ...}]
    Test Calls:
        SELECT ess.fn_read_employee('admin', ARRAY[1,2]);
        SELECT ess.fn_read_employee('admin');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _employee_ids IS NOT NULL THEN
        SELECT json_agg(emp_rec) INTO l_result
        FROM (
            SELECT 
                employee_id,
                employee_name,
                doj,
                total_experience,
                designation,
                reporting_manager,
                work_location,
                personal_email,
                company_email,
                gender,
                date_of_birth,
                present_address,
                permanent_address,
                contact_number,
                alternate_contact_number,
                fathers_name,
                marital_status,
                pan_number,
                aadhar_number,
                blood_group,
                passport_number,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employees
            WHERE employee_id = ANY(_employee_ids)
        ) AS emp_rec;
    ELSE
        SELECT json_agg(emp_rec) INTO l_result
        FROM (
            SELECT 
                employee_id,
                employee_name,
                doj,
                total_experience,
                designation,
                reporting_manager,
                work_location,
                personal_email,
                company_email,
                gender,
                date_of_birth,
                present_address,
                permanent_address,
                contact_number,
                alternate_contact_number,
                fathers_name,
                marital_status,
                pan_number,
                aadhar_number,
                blood_group,
                passport_number,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employees
        ) AS emp_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_employee', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_update_employee(
    _employee_id INTEGER,
    _employee_name TEXT,
    _doj DATE,
    _total_experience NUMERIC(4,2),
    _designation TEXT,
    _reporting_manager TEXT,
    _work_location TEXT,
    _personal_email TEXT,
    _company_email TEXT,
    _gender TEXT,
    _date_of_birth DATE,
    _present_address TEXT,
    _permanent_address TEXT,
    _contact_number TEXT,
    _alternate_contact_number TEXT,
    _fathers_name TEXT,
    _marital_status TEXT,
    _pan_number TEXT,
    _aadhar_number TEXT,
    _blood_group TEXT,
    _passport_number TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_update_employee
    Purpose:  Updates employee details in the ess.employees table for a given employee_id.
    Parameters:
        _employee_id            - Employee ID to update.
        _employee_name          - Employee's name.
        _doj                    - Date of joining.
        _total_experience       - Total years of experience.
        _designation            - Employee's designation.
        _reporting_manager      - Reporting manager's name.
        _work_location          - Work location.
        _personal_email         - Personal email address.
        _company_email          - Company email address.
        _gender                 - Gender.
        _date_of_birth          - Date of birth.
        _present_address        - Present address.
        _permanent_address      - Permanent address.
        _contact_number         - Contact number.
        _alternate_contact_number - Alternate contact number.
        _fathers_name           - Father's name.
        _marital_status         - Marital status.
        _pan_number             - PAN number.
        _aadhar_number          - Aadhar number.
        _blood_group            - Blood group.
        _passport_number        - Passport number.
        _user_id                - User ID executing the function.
    Returns:
        A JSON array containing the updated employee details, e.g.:
        [{"employee_id": 1, "employee_name": "Updated Name", "message": "Employee updated successfully"}]
    Test Call:
        SELECT ess.fn_update_employee(
            1,
            'Updated Name',
            '2020-01-15',
            6.00,
            'Senior Software Engineer',
            'Jane Smith',
            'New York',
            'updated.email@gmail.com',
            'updated.email@company.com',
            'male',
            '1990-05-20',
            '123 New Main St, New York, NY',
            '456 New Elm St, Boston, MA',
            '555-9999',
            'Mary Updated - Wife: 555-8888',
            'Robert Updated',
            'married',
            'ABCDE1234F',
            '123412341234',
            'O+',
            'X1234567',
            'admin'
        );
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.employees
    SET employee_name = _employee_name,
        doj = _doj,
        total_experience = _total_experience,
        designation = _designation,
        reporting_manager = _reporting_manager,
        work_location = _work_location,
        personal_email = _personal_email,
        company_email = _company_email,
        gender = _gender,
        date_of_birth = _date_of_birth,
        present_address = _present_address,
        permanent_address = _permanent_address,
        contact_number = _contact_number,
        alternate_contact_number = _alternate_contact_number,
        fathers_name = _fathers_name,
        marital_status = _marital_status,
        pan_number = _pan_number,
        aadhar_number = _aadhar_number,
        blood_group = _blood_group,
        passport_number = _passport_number,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE employee_id = _employee_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'employee_id', _employee_id,
                            'message', 'No employee found with the provided employee_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'employee_id', _employee_id,
                            'employee_name', _employee_name,
                            'message', 'Employee updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_employee', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_delete_employee(
    _user_id TEXT,
    _employee_id INTEGER
)
RETURNS JSON AS $$
/*
    Function: fn_delete_employee
    Purpose:  Deletes an employee from the ess.employees table based on the provided employee_id.
    Parameters:
        _user_id     - User ID executing the function (used for auditing and exception logging).
        _employee_id - Employee ID to be deleted.
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"employee_id": 1, "message": "Employee deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_employee('admin', 1);
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.employees
    WHERE employee_id = _employee_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'employee_id', _employee_id,
                            'message', 'No employee found with the provided employee_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'employee_id', _employee_id,
                            'message', 'Employee deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_employee', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;








CREATE OR REPLACE FUNCTION ess.fn_create_employee_past_experience(
    _employee_id INTEGER,
    _company_name TEXT,
    _project_name TEXT,
    _client_name TEXT,
    _project_start_date DATE,
    _project_end_date DATE,
    _project_activities TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_create_employee_past_experience
    Purpose:  Inserts a new record into the ess.employee_past_experience table and returns the inserted record in JSON format.
    Parameters:
        _employee_id         - Employee ID (must match the column name, prefixed with _)
        _company_name        - Company name where the employee worked
        _project_name        - Project name associated with the experience
        _client_name         - Client name (optional)
        _project_start_date  - Project start date
        _project_end_date    - Project end date (optional)
        _project_activities  - Description of project activities (optional)
        _user_id             - User ID executing the function (for auditing and exception logging)
    Returns:
        A JSON array containing the inserted record details, e.g.:
        [{"experience_id": 1, "employee_id": 101, "company_name": "ABC Corp", "project_name": "Project Alpha", ... ,"message": "Employee past experience created successfully"}]
    Test Call:
        SELECT ess.fn_create_employee_past_experience(
            101,
            'ABC Corp',
            'Project Alpha',
            'Client A',
            '2018-01-01',
            '2018-06-30',
            'Developed backend APIs',
            'admin'
        );
*/
DECLARE
    l_experience_id INTEGER;  -- Local variable to store the new experience_id
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.employee_past_experience (
        employee_id,
        company_name,
        project_name,
        client_name,
        project_start_date,
        project_end_date,
        project_activities,
        createdby,
        created_timestamp
    )
    VALUES (
        _employee_id,
        _company_name,
        _project_name,
        _client_name,
        _project_start_date,
        _project_end_date,
        _project_activities,
        _user_id,
        CURRENT_TIMESTAMP
    )
    RETURNING experience_id INTO l_experience_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'experience_id', l_experience_id,
                        'employee_id', _employee_id,
                        'company_name', _company_name,
                        'project_name', _project_name,
                        'client_name', _client_name,
                        'project_start_date', _project_start_date,
                        'project_end_date', _project_end_date,
                        'project_activities', _project_activities,
                        'message', 'Employee past experience created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_employee_past_experience', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_read_employee_past_experience(
    _user_id TEXT,
    _experience_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_employee_past_experience
    Purpose:  Reads records from the ess.employee_past_experience table.
              If _experience_ids is provided, returns only those records; otherwise returns all records.
    Parameters:
        _user_id       - User ID executing the function (for auditing and exception logging)
        _experience_ids- Array of experience_id values to filter by (optional)
    Returns:
        A JSON array containing employee past experience records, e.g.:
        [{"experience_id": 1, "employee_id": 101, "company_name": "ABC Corp", ...}]
    Test Calls:
        SELECT ess.fn_read_employee_past_experience('admin', ARRAY[1,2]);
        SELECT ess.fn_read_employee_past_experience('admin');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _experience_ids IS NOT NULL THEN
        SELECT json_agg(exp_rec) INTO l_result
        FROM (
            SELECT 
                experience_id,
                employee_id,
                company_name,
                project_name,
                client_name,
                project_start_date,
                project_end_date,
                project_activities,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_past_experience
            WHERE experience_id = ANY(_experience_ids)
        ) AS exp_rec;
    ELSE
        SELECT json_agg(exp_rec) INTO l_result
        FROM (
            SELECT 
                experience_id,
                employee_id,
                company_name,
                project_name,
                client_name,
                project_start_date,
                project_end_date,
                project_activities,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_past_experience
        ) AS exp_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_employee_past_experience', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_update_employee_past_experience(
    _experience_id INTEGER,
    _employee_id INTEGER,
    _company_name TEXT,
    _project_name TEXT,
    _client_name TEXT,
    _project_start_date DATE,
    _project_end_date DATE,
    _project_activities TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_update_employee_past_experience
    Purpose:  Updates a record in the ess.employee_past_experience table based on the provided experience_id.
    Parameters:
        _experience_id      - Experience ID of the record to update.
        _employee_id        - Employee ID (must match the column name, prefixed with _)
        _company_name       - New company name.
        _project_name       - New project name.
        _client_name        - New client name (optional).
        _project_start_date - New project start date.
        _project_end_date   - New project end date (optional).
        _project_activities - New project activities description (optional).
        _user_id            - User ID executing the function (for auditing and exception logging)
    Returns:
        A JSON array containing a message about the update result, e.g.:
        [{"experience_id": 1, "message": "Employee past experience updated successfully"}]
    Test Call:
        SELECT ess.fn_update_employee_past_experience(
            1,
            101,
            'XYZ Corp',
            'Project Beta',
            'Client B',
            '2019-02-01',
            '2019-08-01',
            'Managed front-end development',
            'admin'
        );
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.employee_past_experience
    SET employee_id = _employee_id,
        company_name = _company_name,
        project_name = _project_name,
        client_name = _client_name,
        project_start_date = _project_start_date,
        project_end_date = _project_end_date,
        project_activities = _project_activities,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE experience_id = _experience_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'experience_id', _experience_id,
                            'message', 'No record found with the provided experience_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'experience_id', _experience_id,
                            'message', 'Employee past experience updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_employee_past_experience', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_delete_employee_past_experience(
    _user_id TEXT,
    _experience_id INTEGER
)
RETURNS JSON AS $$
/*
    Function: fn_delete_employee_past_experience
    Purpose:  Deletes a record from the ess.employee_past_experience table based on the provided experience_id.
    Parameters:
        _user_id      - User ID executing the function (for auditing and exception logging)
        _experience_id- Experience ID of the record to be deleted.
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"experience_id": 1, "message": "Employee past experience deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_employee_past_experience('admin', 1);
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.employee_past_experience
    WHERE experience_id = _experience_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'experience_id', _experience_id,
                            'message', 'No record found with the provided experience_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'experience_id', _experience_id,
                            'message', 'Employee past experience deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_employee_past_experience', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_create_employee_otsi_experience(
    _employee_id INTEGER,
    _project_name TEXT,
    _client_name TEXT,
    _project_start_date DATE,
    _project_end_date DATE,
    _project_activities TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_create_employee_otsi_experience
    Purpose:  Inserts a new record into the ess.employee_otsi_experience table and returns the inserted record in JSON format.
    Parameters:
        _employee_id         - Employee ID associated with the OTSI experience.
        _project_name        - Name of the project.
        _client_name         - Client name.
        _project_start_date  - Project start date.
        _project_end_date    - Project end date.
        _project_activities  - Description of project activities.
        _user_id             - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the inserted record details, e.g.:
        [{"otsi_experience_id": 1, "employee_id": 101, "project_name": "Project X", "client_name": "Client Z", "project_start_date": "2020-05-01", "project_end_date": "2020-11-01", "project_activities": "Developed a web application", "message": "Employee OTSI experience created successfully"}]
    Test Call:
        SELECT ess.fn_create_employee_otsi_experience(
            101,
            'Project X',
            'Client Z',
            '2020-05-01',
            '2020-11-01',
            'Developed a web application',
            'admin'
        );
*/
DECLARE
    l_otsi_experience_id INTEGER;  -- Local variable to store the new OTSI experience ID
    l_result JSON;                   -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.employee_otsi_experience (
        employee_id,
        project_name,
        client_name,
        project_start_date,
        project_end_date,
        project_activities,
        createdby,
        created_timestamp
    )
    VALUES (
        _employee_id,
        _project_name,
        _client_name,
        _project_start_date,
        _project_end_date,
        _project_activities,
        _user_id,
        CURRENT_TIMESTAMP
    )
    RETURNING otsi_experience_id INTO l_otsi_experience_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'otsi_experience_id', l_otsi_experience_id,
                        'employee_id', _employee_id,
                        'project_name', _project_name,
                        'client_name', _client_name,
                        'project_start_date', _project_start_date,
                        'project_end_date', _project_end_date,
                        'project_activities', _project_activities,
                        'message', 'Employee OTSI experience created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_employee_otsi_experience', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ess.fn_read_employee_otsi_experience(
    _user_id TEXT,
    _otsi_experience_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_employee_otsi_experience
    Purpose:  Reads records from the ess.employee_otsi_experience table.
              If _otsi_experience_ids is provided, returns only those records; otherwise returns all records.
    Parameters:
        _user_id              - User ID executing the function.
        _otsi_experience_ids  - Array of OTSI experience IDs to filter by (optional).
    Returns:
        A JSON array containing employee OTSI experience records, e.g.:
        [{"otsi_experience_id": 1, "employee_id": 101, "project_name": "Project X", "client_name": "Client Z", "project_start_date": "2020-05-01", "project_end_date": "2020-11-01", "project_activities": "Developed a web application", ...}]
    Test Calls:
        SELECT ess.fn_read_employee_otsi_experience('admin', ARRAY[1,2]);
        SELECT ess.fn_read_employee_otsi_experience('admin');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _otsi_experience_ids IS NOT NULL THEN
        SELECT json_agg(otsi_rec) INTO l_result
        FROM (
            SELECT
                otsi_experience_id,
                employee_id,
                project_name,
                client_name,
                project_start_date,
                project_end_date,
                project_activities,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_otsi_experience
            WHERE otsi_experience_id = ANY(_otsi_experience_ids)
        ) AS otsi_rec;
    ELSE
        SELECT json_agg(otsi_rec) INTO l_result
        FROM (
            SELECT
                otsi_experience_id,
                employee_id,
                project_name,
                client_name,
                project_start_date,
                project_end_date,
                project_activities,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_otsi_experience
        ) AS otsi_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_employee_otsi_experience', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ess.fn_update_employee_otsi_experience(
    _otsi_experience_id INTEGER,
    _employee_id INTEGER,
    _project_name TEXT,
    _client_name TEXT,
    _project_start_date DATE,
    _project_end_date DATE,
    _project_activities TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_update_employee_otsi_experience
    Purpose:  Updates a record in the ess.employee_otsi_experience table based on the provided otsi_experience_id.
    Parameters:
        _otsi_experience_id - OTSI experience ID of the record to update.
        _employee_id        - Employee ID associated with the record.
        _project_name       - New project name.
        _client_name        - New client name.
        _project_start_date - New project start date.
        _project_end_date   - New project end date.
        _project_activities - New project activities.
        _user_id            - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing a message about the update result, e.g.:
        [{"otsi_experience_id": 1, "message": "Employee OTSI experience updated successfully"}]
    Test Call:
        SELECT ess.fn_update_employee_otsi_experience(
            1,
            101,
            'Project Y',
            'Client A',
            '2021-01-01',
            '2021-06-01',
            'Updated project activities',
            'admin'
        );
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.employee_otsi_experience
    SET employee_id = _employee_id,
        project_name = _project_name,
        client_name = _client_name,
        project_start_date = _project_start_date,
        project_end_date = _project_end_date,
        project_activities = _project_activities,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE otsi_experience_id = _otsi_experience_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'otsi_experience_id', _otsi_experience_id,
                            'message', 'No record found with the provided otsi_experience_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'otsi_experience_id', _otsi_experience_id,
                            'message', 'Employee OTSI experience updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_employee_otsi_experience', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ess.fn_delete_employee_otsi_experience(
    _user_id TEXT,
    _otsi_experience_id INTEGER
)
RETURNS JSON AS $$
/*
    Function: fn_delete_employee_otsi_experience
    Purpose:  Deletes a record from the ess.employee_otsi_experience table based on the provided otsi_experience_id.
    Parameters:
        _user_id            - User ID executing the function (used for auditing and exception logging).
        _otsi_experience_id - OTSI experience ID of the record to be deleted.
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"otsi_experience_id": 1, "message": "Employee OTSI experience deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_employee_otsi_experience('admin', 1);
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.employee_otsi_experience
    WHERE otsi_experience_id = _otsi_experience_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'otsi_experience_id', _otsi_experience_id,
                            'message', 'No record found with the provided otsi_experience_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'otsi_experience_id', _otsi_experience_id,
                            'message', 'Employee OTSI experience deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_employee_otsi_experience', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;




CREATE OR REPLACE FUNCTION ess.fn_create_employee_education(
    _employee_id INTEGER,
    _year_passed_out INTEGER,
    _education TEXT,
    _college_university TEXT,
    _major_subjects TEXT[],
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_create_employee_education
    Purpose:  Inserts a new education record into the ess.employee_education table and returns the inserted record in JSON format.
    Parameters:
        _employee_id        - Employee ID for the education record.
        _year_passed_out    - Year passed out.
        _education          - Education qualification (e.g., B.Tech, MBA).
        _college_university - Name of the college/university.
        _major_subjects     - Array of major subjects.
        _user_id            - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the inserted education record details, e.g.:
        [{"education_id": 1, "employee_id": 1, "year_passed_out": 2012, "education": "B.Tech", "college_university": "MIT", "major_subjects": ["Computer Science", "Engineering"], "message": "Employee education record created successfully"}]
    Test Call:
        SELECT ess.fn_create_employee_education(1, 2012, 'B.Tech', 'MIT', ARRAY['Computer Science', 'Engineering'], 'admin');
*/
DECLARE
    l_education_id INTEGER;  -- Local variable to store the new education_id
    l_result JSON;           -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.employee_education (
        employee_id,
        year_passed_out,
        education,
        college_university,
        major_subjects,
        createdby,
        created_timestamp
    )
    VALUES (
        _employee_id,
        _year_passed_out,
        _education,
        _college_university,
        _major_subjects,
        _user_id,
        CURRENT_TIMESTAMP
    )
    RETURNING education_id INTO l_education_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'education_id', l_education_id,
                        'employee_id', _employee_id,
                        'year_passed_out', _year_passed_out,
                        'education', _education,
                        'college_university', _college_university,
                        'major_subjects', _major_subjects,
                        'message', 'Employee education record created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_employee_education', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_read_employee_education(
    _user_id TEXT,
    _education_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_employee_education
    Purpose:  Reads education records from the ess.employee_education table.
              If _education_ids is provided, returns only those records; otherwise returns all records.
    Parameters:
        _user_id       - User ID executing the function (used for auditing and exception logging).
        _education_ids - Array of education IDs to filter by (optional).
    Returns:
        A JSON array containing education records, e.g.:
        [{"education_id": 1, "employee_id": 1, "year_passed_out": 2012, "education": "B.Tech", "college_university": "MIT", "major_subjects": ["Computer Science", "Engineering"], ...}]
    Test Calls:
        SELECT ess.fn_read_employee_education('admin', ARRAY[1,2]);
        SELECT ess.fn_read_employee_education('admin');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _education_ids IS NOT NULL THEN
        SELECT json_agg(edu_rec) INTO l_result
        FROM (
            SELECT 
                education_id,
                employee_id,
                year_passed_out,
                education,
                college_university,
                major_subjects,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_education
            WHERE education_id = ANY(_education_ids)
        ) AS edu_rec;
    ELSE
        SELECT json_agg(edu_rec) INTO l_result
        FROM (
            SELECT 
                education_id,
                employee_id,
                year_passed_out,
                education,
                college_university,
                major_subjects,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_education
        ) AS edu_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_employee_education', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_update_employee_education(
    _education_id INTEGER,
    _employee_id INTEGER,
    _year_passed_out INTEGER,
    _education TEXT,
    _college_university TEXT,
    _major_subjects TEXT[],
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_update_employee_education
    Purpose:  Updates an education record in the ess.employee_education table for a given education_id.
    Parameters:
        _education_id       - Education ID to update.
        _employee_id        - Employee ID for the record.
        _year_passed_out    - Updated year passed out.
        _education          - Updated education qualification.
        _college_university - Updated college/university name.
        _major_subjects     - Updated array of major subjects.
        _user_id            - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing a message about the update result, e.g.:
        [{"education_id": 1, "message": "Employee education record updated successfully"}]
    Test Call:
        SELECT ess.fn_update_employee_education(1, 1, 2012, 'B.Tech', 'MIT', ARRAY['Computer Science', 'Engineering'], 'admin');
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.employee_education
    SET employee_id = _employee_id,
        year_passed_out = _year_passed_out,
        education = _education,
        college_university = _college_university,
        major_subjects = _major_subjects,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE education_id = _education_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'education_id', _education_id,
                            'message', 'No record found with the provided education_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'education_id', _education_id,
                            'message', 'Employee education record updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_employee_education', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_delete_employee_education(
    _user_id TEXT,
    _education_id INTEGER
)
RETURNS JSON AS $$
/*
    Function: fn_delete_employee_education
    Purpose:  Deletes an education record from the ess.employee_education table based on the provided education_id.
    Parameters:
        _user_id      - User ID executing the function (used for auditing and exception logging).
        _education_id - Education ID of the record to be deleted.
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"education_id": 1, "message": "Employee education record deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_employee_education('admin', 1);
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.employee_education
    WHERE education_id = _education_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'education_id', _education_id,
                            'message', 'No record found with the provided education_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'education_id', _education_id,
                            'message', 'Employee education record deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_employee_education', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;





CREATE OR REPLACE FUNCTION ess.fn_create_employee_skill(
    _employee_id INTEGER,
    _skill_id INTEGER,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_create_employee_skill
    Purpose:  Inserts a new record into the ess.employee_skills table and returns the inserted record in JSON format.
    Parameters:
        _employee_id - Employee ID to associate with the skill.
        _skill_id    - Skill ID to associate.
        _user_id     - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the inserted employee skill record details, e.g.:
        [{"employee_skill_id": 1, "employee_id": 101, "skill_id": 5, "message": "Employee skill created successfully"}]
    Test Call:
        SELECT ess.fn_create_employee_skill(101, 5, 'admin');
*/
DECLARE
    l_employee_skill_id INTEGER;  -- Local variable to store the new employee_skill_id
    l_result JSON;                -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.employee_skills (
        employee_id,
        skill_id,
        createdby,
        created_timestamp
    )
    VALUES (
        _employee_id,
        _skill_id,
        _user_id,
        CURRENT_TIMESTAMP
    )
    RETURNING employee_skill_id INTO l_employee_skill_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'employee_skill_id', l_employee_skill_id,
                        'employee_id', _employee_id,
                        'skill_id', _skill_id,
                        'message', 'Employee skill created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_employee_skill', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_read_employee_skill(
    _user_id TEXT,
    _employee_skill_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_employee_skill
    Purpose:  Reads records from the ess.employee_skills table.
              If _employee_skill_ids is provided, returns only those records; otherwise returns all records.
    Parameters:
        _user_id             - User ID executing the function (used for auditing and exception logging).
        _employee_skill_ids  - Array of employee_skill_id values to filter by (optional).
    Returns:
        A JSON array containing employee skill records, e.g.:
        [{"employee_skill_id": 1, "employee_id": 101, "skill_id": 5, "createdby": "admin", "created_timestamp": "2025-02-01T12:00:00", ...}]
    Test Calls:
        SELECT ess.fn_read_employee_skill('admin', ARRAY[1,2]);
        SELECT ess.fn_read_employee_skill('admin');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _employee_skill_ids IS NOT NULL THEN
        SELECT json_agg(skill_rec) INTO l_result
        FROM (
            SELECT 
                employee_skill_id,
                employee_id,
                skill_id,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_skills
            WHERE employee_skill_id = ANY(_employee_skill_ids)
        ) AS skill_rec;
    ELSE
        SELECT json_agg(skill_rec) INTO l_result
        FROM (
            SELECT 
                employee_skill_id,
                employee_id,
                skill_id,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_skills
        ) AS skill_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_employee_skill', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_update_employee_skill(
    _employee_skill_id INTEGER,
    _employee_id INTEGER,
    _skill_id INTEGER,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_update_employee_skill
    Purpose:  Updates a record in the ess.employee_skills table based on the provided employee_skill_id.
    Parameters:
        _employee_skill_id - Employee skill record ID to update.
        _employee_id       - Updated Employee ID.
        _skill_id          - Updated Skill ID.
        _user_id           - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing a message about the update result, e.g.:
        [{"employee_skill_id": 1, "message": "Employee skill updated successfully"}]
    Test Call:
        SELECT ess.fn_update_employee_skill(1, 101, 6, 'admin');
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.employee_skills
    SET employee_id = _employee_id,
        skill_id = _skill_id,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE employee_skill_id = _employee_skill_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'employee_skill_id', _employee_skill_id,
                            'message', 'No record found with the provided employee_skill_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'employee_skill_id', _employee_skill_id,
                            'message', 'Employee skill updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_employee_skill', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_delete_employee_skill(
    _user_id TEXT,
    _employee_skill_id INTEGER
)
RETURNS JSON AS $$
/*
    Function: fn_delete_employee_skill
    Purpose:  Deletes a record from the ess.employee_skills table based on the provided employee_skill_id.
    Parameters:
        _user_id           - User ID executing the function (used for auditing and exception logging).
        _employee_skill_id - Employee skill record ID to be deleted.
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"employee_skill_id": 1, "message": "Employee skill deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_employee_skill('admin', 1);
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.employee_skills
    WHERE employee_skill_id = _employee_skill_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'employee_skill_id', _employee_skill_id,
                            'message', 'No record found with the provided employee_skill_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'employee_skill_id', _employee_skill_id,
                            'message', 'Employee skill deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_employee_skill', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION ess.fn_create_employee_certification(
    _employee_id INTEGER,
    _certification_name TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_create_employee_certification
    Purpose:  Inserts a new record into the ess.employee_certifications table and returns the inserted record in JSON format.
    Parameters:
        _employee_id         - Employee ID for the certification.
        _certification_name  - Certification name.
        _user_id             - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the inserted record details, e.g.:
        [{"employee_certification_id": 1, "employee_id": 1, "certification_name": "Certified Java Developer", "message": "Employee certification created successfully"}]
    Test Call:
        SELECT ess.fn_create_employee_certification(1, 'Certified Java Developer', 'admin');
*/
DECLARE
    l_employee_certification_id INTEGER;  -- Local variable to store the new certification ID
    l_result JSON;                        -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.employee_certifications (
        employee_id,
        certification_name,
        createdby,
        created_timestamp
    )
    VALUES (
        _employee_id,
        _certification_name,
        _user_id,
        CURRENT_TIMESTAMP
    )
    RETURNING employee_certification_id INTO l_employee_certification_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'employee_certification_id', l_employee_certification_id,
                        'employee_id', _employee_id,
                        'certification_name', _certification_name,
                        'message', 'Employee certification created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_employee_certification', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_read_employee_certification(
    _user_id TEXT,
    _employee_certification_ids INTEGER[] DEFAULT NULL
)
RETURNS JSON AS $$
/*
    Function: fn_read_employee_certification
    Purpose:  Reads records from the ess.employee_certifications table.
              If _employee_certification_ids is provided, returns only those records; otherwise returns all records.
    Parameters:
        _user_id                     - User ID executing the function.
        _employee_certification_ids  - Array of certification IDs to filter by (optional).
    Returns:
        A JSON array containing certification records, e.g.:
        [{"employee_certification_id": 1, "employee_id": 1, "certification_name": "Certified Java Developer", ...}]
    Test Calls:
        SELECT ess.fn_read_employee_certification('admin', ARRAY[1,2]);
        SELECT ess.fn_read_employee_certification('admin');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _employee_certification_ids IS NOT NULL THEN
        SELECT json_agg(cert_rec) INTO l_result
        FROM (
            SELECT 
                employee_certification_id,
                employee_id,
                certification_name,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_certifications
            WHERE employee_certification_id = ANY(_employee_certification_ids)
        ) AS cert_rec;
    ELSE
        SELECT json_agg(cert_rec) INTO l_result
        FROM (
            SELECT 
                employee_certification_id,
                employee_id,
                certification_name,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.employee_certifications
        ) AS cert_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_employee_certification', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_update_employee_certification(
    _employee_certification_id INTEGER,
    _employee_id INTEGER,
    _certification_name TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_update_employee_certification
    Purpose:  Updates a record in the ess.employee_certifications table for a given certification ID.
    Parameters:
        _employee_certification_id - Certification record ID to update.
        _employee_id               - Updated Employee ID.
        _certification_name        - Updated Certification Name.
        _user_id                   - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing a message about the update result, e.g.:
        [{"employee_certification_id": 1, "message": "Employee certification updated successfully"}]
    Test Call:
        SELECT ess.fn_update_employee_certification(1, 1, 'Certified Python Developer', 'admin');
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.employee_certifications
    SET employee_id = _employee_id,
        certification_name = _certification_name,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE employee_certification_id = _employee_certification_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'employee_certification_id', _employee_certification_id,
                            'message', 'No record found with the provided employee_certification_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'employee_certification_id', _employee_certification_id,
                            'message', 'Employee certification updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_employee_certification', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_delete_employee_certification(
    _user_id TEXT,
    _employee_certification_id INTEGER
)
RETURNS JSON AS $$
/*
    Function: fn_delete_employee_certification
    Purpose:  Deletes a record from the ess.employee_certifications table based on the provided certification ID.
    Parameters:
        _user_id                   - User ID executing the function (used for auditing and exception logging).
        _employee_certification_id - Certification record ID to be deleted.
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"employee_certification_id": 1, "message": "Employee certification deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_employee_certification('admin', 1);
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.employee_certifications
    WHERE employee_certification_id = _employee_certification_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'employee_certification_id', _employee_certification_id,
                            'message', 'No record found with the provided employee_certification_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'employee_certification_id', _employee_certification_id,
                            'message', 'Employee certification deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_employee_certification', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_create_otp(
    _user_id TEXT,              -- Executing user ID (for auditing and exception logging)
    _otp_user_id INTEGER,       -- OTP record's user_id (the user for whom the OTP is generated)
    _otp_code TEXT,             -- OTP code
    _otp_status TEXT,           -- OTP status
    _valid_until TIMESTAMP      -- Valid until timestamp
)
RETURNS JSON AS $$
/*
    Function: fn_create_otp
    Purpose:  Inserts a new OTP record into the ess.otp table and returns the inserted record in JSON format.
    Parameters:
        _user_id      - Executing user ID (for auditing and exception logging).
        _otp_user_id  - OTP record's user_id (the user for whom the OTP is generated).
        _otp_code     - OTP code.
        _otp_status   - OTP status.
        _valid_until  - Valid until timestamp.
    Returns:
        A JSON array containing the inserted OTP record details, e.g.:
        [{"otp_id": 1, "user_id": 101, "otp_code": "123456", "otp_status": "pending", "valid_until": "2025-02-01T12:00:00", "message": "OTP created successfully"}]
    Test Call:
        SELECT ess.fn_create_otp('admin', 101, '123456', 'pending', '2025-02-01 12:00:00');
*/
DECLARE
    l_otp_id INTEGER;  -- Local variable to store the new otp_id
    l_result JSON;     -- Local variable to store the JSON result
BEGIN
    INSERT INTO ess.otp (
        user_id,
        otp_code,
        otp_status,
        valid_until,
        createdby,
        created_timestamp
    )
    VALUES (
        _otp_user_id,
        _otp_code,
        _otp_status,
        _valid_until,
        _user_id,
        CURRENT_TIMESTAMP
    )
    RETURNING otp_id INTO l_otp_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'otp_id', l_otp_id,
                        'user_id', _otp_user_id,
                        'otp_code', _otp_code,
                        'otp_status', _otp_status,
                        'valid_until', _valid_until,
                        'message', 'OTP created successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_create_otp', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_read_otp(
    _user_id TEXT,               -- Executing user ID (for auditing and exception logging)
    _otp_ids INTEGER[] DEFAULT NULL  -- Array of OTP IDs to filter by (optional)
)
RETURNS JSON AS $$
/*
    Function: fn_read_otp
    Purpose:  Reads OTP records from the ess.otp table.
              If _otp_ids is provided, returns only those records; otherwise returns all records.
    Parameters:
        _user_id - Executing user ID.
        _otp_ids - Array of otp_id values to filter by (optional).
    Returns:
        A JSON array containing OTP records, e.g.:
        [{"otp_id": 1, "user_id": 101, "otp_code": "123456", "otp_status": "pending", "valid_until": "2025-02-01T12:00:00", ...}]
    Test Calls:
        SELECT ess.fn_read_otp('admin', ARRAY[1,2]);
        SELECT ess.fn_read_otp('admin');
*/
DECLARE
    l_result JSON;  -- Local variable to store the JSON result
BEGIN
    IF _otp_ids IS NOT NULL THEN
        SELECT json_agg(otp_rec) INTO l_result
        FROM (
            SELECT 
                otp_id,
                user_id,
                otp_code,
                otp_status,
                valid_until,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.otp
            WHERE otp_id = ANY(_otp_ids)
        ) AS otp_rec;
    ELSE
        SELECT json_agg(otp_rec) INTO l_result
        FROM (
            SELECT 
                otp_id,
                user_id,
                otp_code,
                otp_status,
                valid_until,
                createdby,
                created_timestamp,
                modifiedby,
                modified_timestamp
            FROM ess.otp
        ) AS otp_rec;
    END IF;
    
    IF l_result IS NULL THEN
        l_result := '[]'::JSON;
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_read_otp', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_update_otp(
    _user_id TEXT,          -- Executing user ID (for auditing and exception logging)
    _otp_id INTEGER,        -- OTP ID to update
    _otp_code TEXT,         -- New OTP code
    _otp_status TEXT,       -- New OTP status
    _valid_until TIMESTAMP  -- New valid until timestamp
)
RETURNS JSON AS $$
/*
    Function: fn_update_otp
    Purpose:  Updates an OTP record in the ess.otp table for a given otp_id.
    Parameters:
        _user_id   - Executing user ID.
        _otp_id    - OTP ID of the record to update.
        _otp_code  - New OTP code.
        _otp_status- New OTP status.
        _valid_until - New valid until timestamp.
    Returns:
        A JSON array containing a message about the update result, e.g.:
        [{"otp_id": 1, "message": "OTP updated successfully"}]
    Test Call:
        SELECT ess.fn_update_otp('admin', 1, '654321', 'used', '2025-02-01 12:05:00');
*/
DECLARE
    l_updated_count INTEGER;  -- Local variable to store the number of rows updated
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    UPDATE ess.otp
    SET otp_code = _otp_code,
        otp_status = _otp_status,
        valid_until = _valid_until,
        modifiedby = _user_id,
        modified_timestamp = CURRENT_TIMESTAMP
    WHERE otp_id = _otp_id;
    
    GET DIAGNOSTICS l_updated_count = ROW_COUNT;
    
    IF l_updated_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'otp_id', _otp_id,
                            'message', 'No OTP record found with the provided otp_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'otp_id', _otp_id,
                            'message', 'OTP updated successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_update_otp', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION ess.fn_delete_otp(
    _user_id TEXT,   -- Executing user ID (for auditing and exception logging)
    _otp_id INTEGER  -- OTP ID to be deleted
)
RETURNS JSON AS $$
/*
    Function: fn_delete_otp
    Purpose:  Deletes an OTP record from the ess.otp table based on the provided otp_id.
    Parameters:
        _user_id - Executing user ID.
        _otp_id  - OTP ID of the record to be deleted.
    Returns:
        A JSON array containing a message about the deletion result, e.g.:
        [{"otp_id": 1, "message": "OTP deleted successfully"}]
    Test Call:
        SELECT ess.fn_delete_otp('admin', 1);
*/
DECLARE
    l_deleted_count INTEGER;  -- Local variable to store the number of rows deleted
    l_result JSON;            -- Local variable to store the JSON result
BEGIN
    DELETE FROM ess.otp
    WHERE otp_id = _otp_id;
    
    GET DIAGNOSTICS l_deleted_count = ROW_COUNT;
    
    IF l_deleted_count = 0 THEN
        l_result := json_build_array(
                        json_build_object(
                            'otp_id', _otp_id,
                            'message', 'No OTP record found with the provided otp_id'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'otp_id', _otp_id,
                            'message', 'OTP deleted successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_delete_otp', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION ess.fn_calculate_total_experience(
    _employee_id INTEGER,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_calculate_total_experience
    Purpose:  Calculates the total experience for an employee by summing up the durations from 
              employee_past_experience and employee_otsi_experience tables, and returns the total in years.
    Parameters:
        _employee_id - Employee ID for which to calculate total experience.
        _user_id     - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the employee ID and the calculated total experience, e.g.:
        [{"employee_id": 1, "total_experience": 7.25, "message": "Total experience calculated successfully"}]
    Test Call:
        SELECT ess.fn_calculate_total_experience(1, 'admin');
*/
DECLARE
    l_past_exp NUMERIC(6,2) := 0;   -- Local variable for past experience in years
    l_otsi_exp NUMERIC(6,2) := 0;   -- Local variable for OTSI experience in years
    l_total_exp NUMERIC(6,2) := 0;    -- Local variable for total experience in years
    l_result JSON;                  -- Local variable to store the JSON result
BEGIN
    -- Calculate past experience from employee_past_experience table
    SELECT COALESCE(SUM(EXTRACT(DAY FROM (project_end_date - project_start_date)) / 365.25), 0)
    INTO l_past_exp
    FROM ess.employee_past_experience
    WHERE employee_id = _employee_id;

    -- Calculate OTSI experience from employee_otsi_experience table
    SELECT COALESCE(SUM(EXTRACT(DAY FROM (project_end_date - project_start_date)) / 365.25), 0)
    INTO l_otsi_exp
    FROM ess.employee_otsi_experience
    WHERE employee_id = _employee_id;

    l_total_exp := l_past_exp + l_otsi_exp;

    l_result := json_build_array(
                    json_build_object(
                        'employee_id', _employee_id,
                        'total_experience', l_total_exp,
                        'message', 'Total experience calculated successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_calculate_total_experience', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ess.fn_generate_otp(
    _otp_user_id INTEGER,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_generate_otp
    Purpose:  Generates a random OTP code for a given user, inserts it into the ess.otp table with a status of 'pending'
              and a validity period of 10 minutes, and returns the OTP details in JSON format.
    Parameters:
        _otp_user_id - User ID for whom the OTP is generated.
        _user_id     - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the generated OTP details, e.g.:
        [{"otp_id": 1, "user_id": 101, "otp_code": "654321", "otp_status": "pending", "valid_until": "2025-02-01T12:10:00", "message": "OTP generated successfully"}]
    Test Call:
        SELECT ess.fn_generate_otp(101, 'admin');
*/
DECLARE
    l_otp_code TEXT;           -- Local variable to store the generated OTP code
    l_valid_until TIMESTAMP;   -- Local variable for OTP validity timestamp
    l_otp_id INTEGER;          -- Local variable to store the new OTP record ID
    l_result JSON;             -- Local variable to store the JSON result
BEGIN
    -- Generate a 6-digit OTP code
    l_otp_code := (floor(random() * 900000 + 100000))::TEXT;
    -- Set validity period to 10 minutes from now
    l_valid_until := CURRENT_TIMESTAMP + INTERVAL '10 minutes';
    
    INSERT INTO ess.otp (
        user_id,
        otp_code,
        otp_status,
        valid_until,
        createdby,
        created_timestamp
    )
    VALUES (
        _otp_user_id,
        l_otp_code,
        'pending',
        l_valid_until,
        _user_id,
        CURRENT_TIMESTAMP
    )
    RETURNING otp_id INTO l_otp_id;
    
    l_result := json_build_array(
                    json_build_object(
                        'otp_id', l_otp_id,
                        'user_id', _otp_user_id,
                        'otp_code', l_otp_code,
                        'otp_status', 'pending',
                        'valid_until', l_valid_until,
                        'message', 'OTP generated successfully'
                    )
                );
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_generate_otp', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ess.fn_validate_otp(
    _otp_user_id INTEGER,
    _otp_code TEXT,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_validate_otp
    Purpose:  Validates the provided OTP code for a given user by checking if there's a pending OTP record
              that matches the code and is still valid. If valid, updates the OTP status to 'used' and returns a success message.
    Parameters:
        _otp_user_id - User ID for whom the OTP was generated.
        _otp_code    - OTP code to validate.
        _user_id     - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing a message about the validation result, e.g.:
        [{"user_id": 101, "message": "OTP validated successfully"}]
    Test Call:
        SELECT ess.fn_validate_otp(101, '654321', 'admin');
*/
DECLARE
    l_count INTEGER;         -- Local variable to store the count of matching OTP records
    l_result JSON;           -- Local variable to store the JSON result
BEGIN
    -- Check if a pending OTP record exists for the user with the provided OTP code and still valid
    SELECT COUNT(*) INTO l_count
    FROM ess.otp
    WHERE user_id = _otp_user_id
      AND otp_code = _otp_code
      AND otp_status = 'pending'
      AND valid_until > CURRENT_TIMESTAMP;
    
    IF l_count > 0 THEN
        -- Update the OTP status to 'used'
        UPDATE ess.otp
        SET otp_status = 'used',
            modifiedby = _user_id,
            modified_timestamp = CURRENT_TIMESTAMP
        WHERE user_id = _otp_user_id
          AND otp_code = _otp_code
          AND otp_status = 'pending';
          
        l_result := json_build_array(
                        json_build_object(
                            'user_id', _otp_user_id,
                            'message', 'OTP validated successfully'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'user_id', _otp_user_id,
                            'message', 'Invalid or expired OTP'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_validate_otp', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION ess.fn_get_reporting_manager(
    _employee_id INTEGER,
    _user_id TEXT
)
RETURNS JSON AS $$
/*
    Function: fn_get_reporting_manager
    Purpose:  Retrieves the reporting manager for a given employee from the ess.employees table.
    Parameters:
        _employee_id - Employee ID for which to retrieve the reporting manager.
        _user_id     - User ID executing the function (used for auditing and exception logging).
    Returns:
        A JSON array containing the reporting manager information, e.g.:
        [{"employee_id": 1, "reporting_manager": "Jane Smith", "message": "Reporting manager retrieved successfully"}]
    Test Call:
        SELECT ess.fn_get_reporting_manager(1, 'admin');
*/
DECLARE
    l_reporting_manager TEXT;  -- Local variable to store the reporting manager
    l_result JSON;             -- Local variable to store the JSON result
BEGIN
    SELECT reporting_manager INTO l_reporting_manager
    FROM ess.employees
    WHERE employee_id = _employee_id;
    
    IF l_reporting_manager IS NULL THEN
        l_result := json_build_array(
                        json_build_object(
                            'employee_id', _employee_id,
                            'message', 'No reporting manager found'
                        )
                    );
    ELSE
        l_result := json_build_array(
                        json_build_object(
                            'employee_id', _employee_id,
                            'reporting_manager', l_reporting_manager,
                            'message', 'Reporting manager retrieved successfully'
                        )
                    );
    END IF;
    
    RETURN l_result;
EXCEPTION
    WHEN OTHERS THEN
        INSERT INTO ess.exception_log(function_name, error_message, executed_by)
        VALUES ('fn_get_reporting_manager', SQLERRM, _user_id);
        RETURN json_build_array(json_build_object('error', SQLERRM));
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE VIEW ess.fn_get_employee_summary AS
SELECT 
    e.employee_id,
    e.employee_name,
    e.designation,
    e.total_experience,
    e.work_location,
    COALESCE(p.exp_count, 0) AS past_experience_count,
    COALESCE(o.otsi_count, 0) AS otsi_experience_count,
    COALESCE(c.cert_count, 0) AS certification_count,
    COALESCE(s.skill_count, 0) AS skill_count
FROM ess.employees e
LEFT OUTER JOIN (
    SELECT employee_id, COUNT(*) AS exp_count
    FROM ess.employee_past_experience
    GROUP BY employee_id
) p ON e.employee_id = p.employee_id
LEFT OUTER JOIN (
    SELECT employee_id, COUNT(*) AS otsi_count
    FROM ess.employee_otsi_experience
    GROUP BY employee_id
) o ON e.employee_id = o.employee_id
LEFT OUTER JOIN (
    SELECT employee_id, COUNT(*) AS cert_count
    FROM ess.employee_certifications
    GROUP BY employee_id
) c ON e.employee_id = c.employee_id
LEFT OUTER JOIN (
    SELECT employee_id, COUNT(*) AS skill_count
    FROM ess.employee_skills
    GROUP BY employee_id
) s ON e.employee_id = s.employee_id;



CREATE OR REPLACE VIEW ess.fn_get_employee_list AS
SELECT 
    e.employee_id,
    e.employee_name,
    e.doj,
    e.total_experience,
    e.designation,
    e.reporting_manager,
    e.work_location,
    e.personal_email,
    e.company_email,
    e.contact_number,
    COALESCE(p.exp_count, 0) AS past_experience_count,
    COALESCE(o.otsi_count, 0) AS otsi_experience_count,
    COALESCE(c.cert_count, 0) AS certification_count,
    COALESCE(s.skill_count, 0) AS skill_count
FROM ess.employees e
LEFT OUTER JOIN (
    SELECT employee_id, COUNT(*) AS exp_count
    FROM ess.employee_past_experience
    GROUP BY employee_id
) p ON e.employee_id = p.employee_id
LEFT OUTER JOIN (
    SELECT employee_id, COUNT(*) AS otsi_count
    FROM ess.employee_otsi_experience
    GROUP BY employee_id
) o ON e.employee_id = o.employee_id
LEFT OUTER JOIN (
    SELECT employee_id, COUNT(*) AS cert_count
    FROM ess.employee_certifications
    GROUP BY employee_id
) c ON e.employee_id = c.employee_id
LEFT OUTER JOIN (
    SELECT employee_id, COUNT(*) AS skill_count
    FROM ess.employee_skills
    GROUP BY employee_id
) s ON e.employee_id = s.employee_id;



CREATE OR REPLACE VIEW ess.fn_get_employee_detail AS
SELECT 
    e.employee_id,
    e.employee_name,
    e.doj,
    e.total_experience,
    e.designation,
    e.reporting_manager,
    e.work_location,
    e.personal_email,
    e.company_email,
    e.contact_number,
    e.alternate_contact_number,
    e.gender,
    e.date_of_birth,
    e.present_address,
    e.permanent_address,
    e.fathers_name,
    e.marital_status,
    e.pan_number,
    e.aadhar_number,
    e.blood_group,
    e.passport_number,
    p.past_experiences,
    o.otsi_experiences,
    edu.education_details,
    c.certifications,
    s.skills
FROM ess.employees e
LEFT OUTER JOIN (
    SELECT 
        employee_id,
        json_agg(
            json_build_object(
                'experience_id', experience_id,
                'company_name', company_name,
                'project_name', project_name,
                'client_name', client_name,
                'project_start_date', project_start_date,
                'project_end_date', project_end_date,
                'project_activities', project_activities
            )
        ) AS past_experiences
    FROM ess.employee_past_experience
    GROUP BY employee_id
) p ON e.employee_id = p.employee_id
LEFT OUTER JOIN (
    SELECT 
        employee_id,
        json_agg(
            json_build_object(
                'otsi_experience_id', otsi_experience_id,
                'project_name', project_name,
                'client_name', client_name,
                'project_start_date', project_start_date,
                'project_end_date', project_end_date,
                'project_activities', project_activities
            )
        ) AS otsi_experiences
    FROM ess.employee_otsi_experience
    GROUP BY employee_id
) o ON e.employee_id = o.employee_id
LEFT OUTER JOIN (
    SELECT 
        employee_id,
        json_agg(
            json_build_object(
                'education_id', education_id,
                'year_passed_out', year_passed_out,
                'education', education,
                'college_university', college_university,
                'major_subjects', major_subjects
            )
        ) AS education_details
    FROM ess.employee_education
    GROUP BY employee_id
) edu ON e.employee_id = edu.employee_id
LEFT OUTER JOIN (
    SELECT 
        employee_id,
        json_agg(
            json_build_object(
                'employee_certification_id', employee_certification_id,
                'certification_name', certification_name
            )
        ) AS certifications
    FROM ess.employee_certifications
    GROUP BY employee_id
) c ON e.employee_id = c.employee_id
LEFT OUTER JOIN (
    SELECT 
        employee_id,
        json_agg(
            json_build_object(
                'employee_skill_id', employee_skill_id,
                'skill_id', skill_id
            )
        ) AS skills
    FROM ess.employee_skills
    GROUP BY employee_id
) s ON e.employee_id = s.employee_id;





CREATE OR REPLACE FUNCTION ess.reporting(
    _input_json JSON,
    _user_id INT,
    _view_name TEXT
) RETURNS JSON AS $$
DECLARE
    l_select_clause TEXT = '';
    l_where_clause TEXT = '';
    l_groupby_clause TEXT = '';
    l_having_clause TEXT = '';
    l_orderby_clause TEXT = '';
    l_limit_clause TEXT = '';
    l_offset_clause TEXT = '';
    l_query TEXT = '';
    l_result JSON;
    l_col TEXT;             -- Loop variable for select clause elements
    l_condition JSON;       -- Loop variable for where clause conditions
    l_column_name TEXT;
    l_operator TEXT;
    l_value TEXT;
    l_agg_col JSON;         -- Loop variable for aggregated_columns elements
    l_having_cond JSON;     -- Loop variable for having clause conditions
BEGIN
    /*
     * -- Test Call Example:
     -- SELECT get_employee_info('{"select": ["employee_id", "employee_name"], "groupby": ["department_name"], "aggregated_columns": [{"column_name": "total_experience", "aggregation": "SUM", "number_of_decimals": 2}], "having": [{"column_name": "total_experience", "aggregation": "SUM", "number_of_decimals": 2, "OP": "GT", "value": 5}], "limit": 10, "offset": 0}', 1, 'employee_detail_view');
     */

    -- Validate input JSON parameters
    IF _input_json->'groupby' IS NULL AND (_input_json->'aggregated_columns' IS NOT NULL OR _input_json->'having' IS NOT NULL) THEN
        RAISE EXCEPTION 'Invalid input: groupby must be provided if aggregated_columns or having is specified';
    END IF;

    IF _input_json->>'limit' IS NOT NULL AND NOT (_input_json->>'limit')::TEXT ~ '^\\d+$' THEN
        RAISE EXCEPTION 'Invalid input: limit must be an integer';
    END IF;

    IF _input_json->>'offset' IS NOT NULL AND NOT (_input_json->>'offset')::TEXT ~ '^\\d+$' THEN
        RAISE EXCEPTION 'Invalid input: offset must be an integer';
    END IF;

    -- Validate column names in select clause
    IF _input_json->'select' IS NOT NULL THEN
        FOR l_col IN SELECT json_array_elements_text(_input_json->'select')
        LOOP
            IF NOT EXISTS (
                SELECT 1 
                FROM information_schema.columns 
                WHERE table_name = _view_name 
                  AND column_name = l_col
            ) THEN
                RAISE EXCEPTION 'Invalid column name in select: %', l_col;
            END IF;
        END LOOP;
    END IF;

    -- Validate operators in where clause
    IF _input_json->'where' IS NOT NULL THEN
        FOR l_condition IN SELECT * FROM json_array_elements(_input_json->'where')
        LOOP
            IF NOT (l_condition->>'OP' IN ('NOT IN', 'IN', 'EQ', 'NE', 'GT', 'LT', 'BETWEEN', 'ILIKE')) THEN
                RAISE EXCEPTION 'Invalid operator in where clause: %', l_condition->>'OP';
            END IF;
        END LOOP;
    END IF;

    -- Formulate SELECT clause
    IF _input_json->'select' IS NOT NULL THEN
        l_select_clause := array_to_string(ARRAY(SELECT json_array_elements_text(_input_json->'select')), ', ');
    END IF;

    -- Formulate WHERE clause
    IF _input_json->'where' IS NOT NULL THEN
        FOR l_condition IN SELECT * FROM json_array_elements(_input_json->'where')
        LOOP
            l_column_name := l_condition->>'column_name';
            l_operator := l_condition->>'OP';
            l_value := l_condition->>'value';

            IF l_operator = 'EQ' THEN
                l_where_clause := l_where_clause || format('%I = %L AND ', l_column_name, l_value);
            ELSIF l_operator = 'NE' THEN
                l_where_clause := l_where_clause || format('%I <> %L AND ', l_column_name, l_value);
            ELSIF l_operator = 'GT' THEN
                l_where_clause := l_where_clause || format('%I > %L AND ', l_column_name, l_value);
            ELSIF l_operator = 'LT' THEN
                l_where_clause := l_where_clause || format('%I < %L AND ', l_column_name, l_value);
            ELSIF l_operator = 'ILIKE' THEN
                l_where_clause := l_where_clause || format('%I ILIKE %L AND ', l_column_name, '%' || l_value || '%');
            ELSIF l_operator = 'IN' THEN
                l_where_clause := l_where_clause || format('%I IN (%s) AND ', l_column_name, 
                    array_to_string(ARRAY(SELECT quote_literal(value) FROM json_array_elements_text(l_condition->'value')), ', '));
            ELSIF l_operator = 'NOT IN' THEN
                l_where_clause := l_where_clause || format('%I NOT IN (%s) AND ', l_column_name, 
                    array_to_string(ARRAY(SELECT quote_literal(value) FROM json_array_elements_text(l_condition->'value')), ', '));
            ELSIF l_operator = 'BETWEEN' THEN
                l_where_clause := l_where_clause || format('%I BETWEEN %L AND %L AND ', l_column_name, l_condition->'value'->>'low', l_condition->'value'->>'high');
            ELSE
                RAISE EXCEPTION 'Unsupported operator: %', l_operator;
            END IF;
        END LOOP;

        l_where_clause := regexp_replace(l_where_clause, ' AND $', '');
    END IF;

    -- Formulate GROUP BY clause
    IF _input_json->'groupby' IS NOT NULL THEN
        l_groupby_clause := array_to_string(ARRAY(SELECT json_array_elements_text(_input_json->'groupby')), ', ');
        l_select_clause := l_groupby_clause || ', ' || l_select_clause;
    END IF;

    -- Formulate Aggregation for SELECT clause
    IF _input_json->'aggregated_columns' IS NOT NULL THEN
        FOR l_agg_col IN SELECT * FROM json_array_elements(_input_json->'aggregated_columns')
        LOOP
            l_select_clause := l_select_clause || ', ' || format('%s(%I)::NUMERIC(%s) AS %I', 
                l_agg_col->>'aggregation', 
                l_agg_col->>'column_name', 
                COALESCE(l_agg_col->>'number_of_decimals', '0'), 
                l_agg_col->>'column_name');
        END LOOP;
    END IF;

    -- Formulate HAVING clause
    IF _input_json->'having' IS NOT NULL THEN
        FOR l_having_cond IN SELECT * FROM json_array_elements(_input_json->'having')
        LOOP
            l_having_clause := l_having_clause || format('%s(%I)::NUMERIC(%s) %s %s AND ',
                l_having_cond->>'aggregation', 
                l_having_cond->>'column_name', 
                COALESCE(l_having_cond->>'number_of_decimals', '0'), 
                l_having_cond->>'OP', 
                CASE 
                    WHEN l_having_cond->>'OP' = 'BETWEEN' THEN format('%L AND %L', l_having_cond->'value'->>'low', l_having_cond->'value'->>'high')
                    ELSE format('%L', l_having_cond->>'value')
                END);
        END LOOP;
        l_having_clause := regexp_replace(l_having_clause, ' AND $', '');
    END IF;

    -- Combine all clauses into a final SQL query
    l_query := 'SELECT ' || l_select_clause || ' FROM ' || quote_ident(_view_name);

    IF l_where_clause <> '' THEN
        l_query := l_query || ' WHERE ' || l_where_clause;
    END IF;

    IF l_groupby_clause <> '' THEN
        l_query := l_query || ' GROUP BY ' || l_groupby_clause;
    END IF;

    IF l_having_clause <> '' THEN
        l_query := l_query || ' HAVING ' || l_having_clause;
    END IF;

    IF l_orderby_clause <> '' THEN
        l_query := l_query || ' ORDER BY ' || l_orderby_clause;
    END IF;

    IF l_limit_clause <> '' THEN
        l_query := l_query || ' LIMIT ' || l_limit_clause;
    END IF;

    IF l_offset_clause <> '' THEN
        l_query := l_query || ' OFFSET ' || l_offset_clause;
    END IF;

    -- Execute the query and prepare the result in JSON format
    EXECUTE l_query INTO l_result;
    l_result := json_build_object(
        'status', 'success',
        'message', 'Query executed successfully',
        'data', l_result
    );

    RETURN l_result;

EXCEPTION WHEN OTHERS THEN
    -- Log exception to the exception_log table
    INSERT INTO exception_log (function_name, error_message, executed_timestamp, executed_by)
    VALUES ('get_employee_info', SQLERRM, CURRENT_TIMESTAMP, _user_id);

    -- Return the exception in JSON format
    RETURN json_build_object(
        'status', 'error',
        'message', SQLERRM
    );
END;
$$ LANGUAGE plpgsql;
